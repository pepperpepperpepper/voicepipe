#!/usr/bin/env python3
"""Fast voicepipe control with optimal transcription handling"""
import sys
import socket
import json
import os
import subprocess
import time
import shutil
import fcntl
from pathlib import Path

def runtime_dir() -> Path:
    xdg_runtime_dir = os.environ.get("XDG_RUNTIME_DIR")
    if xdg_runtime_dir:
        return Path(xdg_runtime_dir)
    run_user_dir = Path("/run/user") / str(os.getuid())
    if run_user_dir.exists():
        return run_user_dir
    return Path("/tmp")

SOCKET_PATH = runtime_dir() / "voicepipe.sock"

TMP_DIR = Path('/tmp/voicepipe')
TMP_DIR.mkdir(parents=True, exist_ok=True)
LOG_FILE = TMP_DIR / "voicepipe-fast.log"

# When invoked from a hotkey (no tty), stderr is usually discarded. Mirror it to
# a log file so failures (e.g. xdotool) are visible.
def _parent_is_fluxbox():
    try:
        ppid = os.getppid()
        comm_path = Path("/proc") / str(ppid) / "comm"
        if not comm_path.exists():
            return False
        return comm_path.read_text(encoding="utf-8").strip() == "fluxbox"
    except Exception:
        return False

_LOG_ENABLED = (
    (not sys.stderr.isatty())
    or os.environ.get("VOICEPIPE_FAST_LOG") == "1"
    or _parent_is_fluxbox()
)
if _LOG_ENABLED:
    try:
        _log_fh = open(LOG_FILE, "a", buffering=1)
        os.dup2(_log_fh.fileno(), sys.stderr.fileno())
    except Exception:
        pass

DEBOUNCE_FILE = str(TMP_DIR / 'voicepipe-fast.time')
DEBOUNCE_MS = 500  # milliseconds
LOCK_FILE = str(TMP_DIR / 'voicepipe-fast.lock')

TRANSCRIBER_SOCKET = TMP_DIR / 'voicepipe_transcriber.sock'

def get_active_window_id():
    """Best-effort capture of the active window for later typing."""
    xdotool_path = shutil.which("xdotool")
    if not xdotool_path:
        return None
    try:
        result = subprocess.run(
            [xdotool_path, "getactivewindow"],
            capture_output=True,
            text=True,
            timeout=1.0,
            check=False,
        )
        if result.returncode != 0:
            err = (result.stderr or "").strip()
            if err:
                print(f"[XDO] getactivewindow failed: {err}", file=sys.stderr)
            return None
        win = (result.stdout or "").strip()
        return win or None
    except Exception as e:
        print(f"[XDO] getactivewindow error: {e}", file=sys.stderr)
        return None

def type_with_xdotool(text, window_id=None):
    """Type text via xdotool; return True on success."""
    xdotool_path = shutil.which("xdotool")
    if not xdotool_path:
        print("[XDO] xdotool not found in PATH", file=sys.stderr)
        return False

    cmd = [xdotool_path, "type", "--clearmodifiers"]
    if window_id:
        cmd += ["--window", str(window_id)]
    cmd += ["--", text]

    try:
        # Keep this bounded so hotkey invocations can never wedge.
        timeout_s = max(2.0, min(30.0, len(text) / 20.0))
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=timeout_s,
            check=False,
        )
        if result.returncode != 0:
            err = (result.stderr or "").strip()
            if err:
                print(f"[XDO] type failed (rc={result.returncode}): {err}", file=sys.stderr)
            else:
                print(f"[XDO] type failed (rc={result.returncode})", file=sys.stderr)
            return False
        return True
    except subprocess.TimeoutExpired:
        print("[XDO] type timed out", file=sys.stderr)
        return False
    except Exception as e:
        print(f"[XDO] type error: {e}", file=sys.stderr)
        return False

def send_cmd(cmd):
    """Send command to daemon via Unix socket"""
    client = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    # Keep this low-ish for hotkey responsiveness, but high enough to avoid
    # spurious timeouts under load.
    client.settimeout(2.0)
    
    try:
        client.connect(str(SOCKET_PATH))
        client.sendall(json.dumps({"command": cmd}).encode())
        
        # Read response efficiently
        response_data = b""
        while True:
            part = client.recv(4096)
            if not part:
                break
            response_data += part
            # Quick check for complete JSON
            if response_data.endswith(b'}'):
                try:
                    json.loads(response_data)
                    break
                except:
                    continue
        
        return json.loads(response_data.decode())
    finally:
        client.close()

def send_transcribe_request(audio_file):
    """Send audio file to transcriber daemon and stream results."""
    def fallback_transcribe():
        voicepipe_cmd = os.environ.get("VOICEPIPE_CMD") or shutil.which("voicepipe")
        if not voicepipe_cmd:
            # Fluxbox and other WMs often run keybind commands with a minimal PATH
            # that omits ~/.local/bin. Prefer a sibling `voicepipe` next to this
            # script, then fall back to ~/.local/bin explicitly.
            try:
                sibling = Path(__file__).resolve().parent / "voicepipe"
                if sibling.exists() and os.access(sibling, os.X_OK):
                    voicepipe_cmd = str(sibling)
            except Exception:
                pass
        if not voicepipe_cmd:
            try:
                local_bin = Path.home() / ".local" / "bin" / "voicepipe"
                if local_bin.exists() and os.access(local_bin, os.X_OK):
                    voicepipe_cmd = str(local_bin)
            except Exception:
                pass
        if not voicepipe_cmd:
            print("[TRANSCRIBE] voicepipe CLI not found for fallback transcription", file=sys.stderr)
            return ""
        try:
            result = subprocess.run(
                [voicepipe_cmd, "transcribe-file", audio_file],
                capture_output=True,
                text=True,
                timeout=300,
            )
            if result.returncode != 0:
                err = (result.stderr or "").strip()
                if err:
                    print(f"[TRANSCRIBE] Fallback failed: {err}", file=sys.stderr)
                else:
                    print("[TRANSCRIBE] Fallback failed with unknown error", file=sys.stderr)
                return ""
            return (result.stdout or "").strip()
        except Exception as e:
            print(f"[TRANSCRIBE] Fallback error: {e}", file=sys.stderr)
            return ""

    if not TRANSCRIBER_SOCKET.exists():
        print(
            f"[TRANSCRIBE] Transcriber socket not found: {TRANSCRIBER_SOCKET}",
            file=sys.stderr,
        )
        print(
            "[TRANSCRIBE] Start it with: systemctl --user start voicepipe-transcriber.service",
            file=sys.stderr,
        )
        return fallback_transcribe()

    client = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    client.settimeout(60.0)  # Increased timeout
    try:
        client.connect(str(TRANSCRIBER_SOCKET))
        client.send((json.dumps({"audio_file": audio_file}) + '\n').encode())
        
        buffer = ""
        full_text = ""
        while True:
            try:
                chunk = client.recv(4096).decode()
                if not chunk:
                    break
            except socket.timeout:
                print("[TRANSCRIBE] Warning: Read timeout, continuing...", file=sys.stderr)
                continue
            
            buffer += chunk
            while '\n' in buffer:
                line, buffer = buffer.split('\n', 1)
                if line.strip():
                    try:
                        response = json.loads(line)
                        if response.get('type') == 'transcription':
                            text = response.get('text', '')
                            if text:
                                full_text += text
                        elif response.get('type') == 'complete':
                            return full_text
                        elif response.get('type') == 'error':
                            print(f"[TRANSCRIBE] Error: {response.get('message')}", file=sys.stderr)
                            return ''
                    except json.JSONDecodeError:
                        continue
        return full_text
    except Exception as e:
        print(
            f"[TRANSCRIBE] Error connecting to {TRANSCRIBER_SOCKET}: {e}",
            file=sys.stderr,
        )
        return fallback_transcribe()
    finally:
        client.close()

class FileLock:
    """Simple file-based lock using fcntl"""
    def __init__(self, lockfile):
        self.lockfile = lockfile
        self.fd = None
        
    def __enter__(self):
        self.fd = open(self.lockfile, 'w')
        try:
            # Try to acquire exclusive lock (non-blocking)
            fcntl.flock(self.fd, fcntl.LOCK_EX | fcntl.LOCK_NB)
            return self
        except IOError:
            # Lock is held by another process
            self.fd.close()
            self.fd = None
            raise
            
    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.fd:
            fcntl.flock(self.fd, fcntl.LOCK_UN)
            self.fd.close()

def check_debounce():
    """Check if enough time has passed since last invocation"""
    try:
        current_time = int(time.time() * 1000)  # milliseconds
        
        # Try to read last time
        if os.path.exists(DEBOUNCE_FILE):
            with open(DEBOUNCE_FILE, 'r') as f:
                last_time = int(f.read().strip())
                
            if current_time - last_time < DEBOUNCE_MS:
                print(f"[DEBOUNCE] Skipping - last: {last_time}, current: {current_time}, diff: {current_time - last_time}ms", file=sys.stderr)
                return False  # Too soon, ignore
        
        # Write current time
        with open(DEBOUNCE_FILE, 'w') as f:
            f.write(str(current_time))
        
        print(f"[DEBOUNCE] Allowing - current: {current_time}", file=sys.stderr)
        return True
    except Exception as e:
        print(f"[DEBOUNCE] Error: {e}, allowing action", file=sys.stderr)
        return True

def execute_toggle():
    """Execute toggle command logic"""
    try:
        print(f"[TOGGLE] Starting toggle execution", file=sys.stderr)
        status = send_cmd("status")
        print(f"[TOGGLE] Status: {status}", file=sys.stderr)
        
        if status.get('status') == 'recording':
            # Capture the current active window early so we can type back into it
            # after transcription (hotkey invocations sometimes lose focus).
            target_window = get_active_window_id()
            if target_window:
                print(f"[TOGGLE] Target window: {target_window}", file=sys.stderr)
            else:
                print("[TOGGLE] Target window: (unknown)", file=sys.stderr)

            print("[TOGGLE] Recording active, stopping...", file=sys.stderr)
            # Stop and transcribe
            result = send_cmd("stop")
            print(f"[TOGGLE] Stop result: {result}", file=sys.stderr)
            
            if 'error' not in result and 'audio_file' in result:
                audio_file = result['audio_file']
                print(f"[TOGGLE] Audio file: {audio_file}", file=sys.stderr)
                
                text = send_transcribe_request(audio_file)
                if text:
                    cleaned_text = text.rstrip()  # Remove any final trailing whitespace/newlines
                    print(f"[TOGGLE] Transcription: {cleaned_text}", file=sys.stderr)
                    # Always persist the last transcript for debugging/recovery.
                    try:
                        (TMP_DIR / "voicepipe-last.txt").write_text(
                            cleaned_text + "\n", encoding="utf-8"
                        )
                    except Exception:
                        pass
                    typed_ok = type_with_xdotool(cleaned_text, window_id=target_window)
                    if not typed_ok:
                        print("[TOGGLE] Warning: xdotool typing failed", file=sys.stderr)
                    transcription_ok = True
                else:
                    print("[TOGGLE] No transcription returned", file=sys.stderr)
                    transcription_ok = False
                
                # Clean up
                if transcription_ok:
                    if os.path.exists(audio_file):
                        os.unlink(audio_file)
                        print(f"[TOGGLE] Cleaned up audio file: {audio_file}", file=sys.stderr)
                else:
                    print(f"[TOGGLE] Preserving audio file for debugging: {audio_file}", file=sys.stderr)
            else:
                print(f"[TOGGLE] Stop error: {result.get('error', 'Unknown error')}", file=sys.stderr)
        else:
            print("[TOGGLE] Starting recording...", file=sys.stderr)
            # Start recording
            result = send_cmd("start")
            print(f"[TOGGLE] Start result: {result}", file=sys.stderr)
            if 'error' in result:
                print(f"[TOGGLE] Start error: {result['error']}", file=sys.stderr)
    except socket.error as e:
        print(f"[TOGGLE] Socket error: {e}", file=sys.stderr)
        print("Error: Cannot connect to voicepipe daemon. Is it running?", file=sys.stderr)
        print("Start it with: systemctl --user start voicepipe-recorder.service", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"[TOGGLE] Unexpected error: {e}", file=sys.stderr)
        raise

def main():
    if len(sys.argv) < 2:
        print("Usage: voicepipe-fast [start|stop|toggle]")
        sys.exit(1)
    
    cmd = sys.argv[1]
    
    # For toggle command, use file locking to prevent concurrent execution
    if cmd == "toggle":
        try:
            print(f"[MAIN] Toggle command received", file=sys.stderr)
            with FileLock(LOCK_FILE):
                print(f"[MAIN] Lock acquired", file=sys.stderr)
                # Also check debounce inside the lock to prevent rapid toggles
                if not check_debounce():
                    print("[MAIN] Debounced, exiting", file=sys.stderr)
                    sys.exit(0)  # Exit silently if debounced
                print("[MAIN] Executing toggle", file=sys.stderr)
                execute_toggle()
                print("[MAIN] Toggle completed", file=sys.stderr)
                return
        except IOError:
            print("[MAIN] Lock already held, exiting", file=sys.stderr)
            # Another instance is running, exit silently
            sys.exit(0)
    
    try:
        if cmd == "start":
            status = send_cmd("status")
            if status.get('status') == 'recording':
                sys.exit(0)  # Already recording, exit silently
            
            result = send_cmd("start")
            if 'error' in result:
                print(f"Error: {result['error']}", file=sys.stderr)
                sys.exit(1)
                
        elif cmd == "stop":
            status = send_cmd("status")
            if status.get('status') != 'recording':
                sys.exit(0)  # Not recording, exit silently
                
            result = send_cmd("stop")
            if 'error' not in result and 'audio_file' in result:
                audio_file = result['audio_file']
                if os.path.exists(audio_file) and os.path.getsize(audio_file) > 0:
                    text = send_transcribe_request(audio_file)
                    # Output text
                    if text:
                        print(text)
                    # Clean up
                    if text and os.path.exists(audio_file):
                        os.unlink(audio_file)
                    elif not text:
                        print(
                            f"[STOP] Preserving audio file for debugging: {audio_file}",
                            file=sys.stderr,
                        )
            else:
                if 'error' in result:
                    print(f"Error: {result['error']}", file=sys.stderr)
                    
    except socket.error:
        print("Error: Cannot connect to voicepipe daemon. Is it running?", file=sys.stderr)
        print("Start it with: systemctl --user start voicepipe-recorder.service", file=sys.stderr)
        sys.exit(1)
    except KeyboardInterrupt:
        # Handle Ctrl+C gracefully
        sys.exit(130)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()
