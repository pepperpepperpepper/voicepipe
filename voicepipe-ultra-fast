#!/usr/bin/env python3
"""Ultra-fast voicepipe control using separate transcriber daemon"""
import sys
import socket
import json
import os
import subprocess

VOICEPIPE_SOCKET = '/tmp/voicepipe.sock'
TRANSCRIBER_SOCKET = '/tmp/voicepipe_transcriber.sock'

def send_cmd(cmd, socket_path=VOICEPIPE_SOCKET):
    """Send command via Unix socket"""
    client = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    client.connect(socket_path)
    
    client.sendall(json.dumps({"command": cmd} if isinstance(cmd, str) else cmd).encode())
    
    # Read response
    response_data = b""
    while True:
        part = client.recv(4096)
        if not part:
            break
        response_data += part
        if response_data.endswith(b'}'):
            try:
                json.loads(response_data.decode())
                break
            except:
                continue
    
    client.close()
    return json.loads(response_data.decode())

def transcribe_audio(audio_file):
    """Transcribe using the daemon"""
    try:
        return send_cmd({"audio_file": audio_file}, TRANSCRIBER_SOCKET)
    except socket.error:
        # Fallback to regular transcriber if daemon not running
        from voicepipe.transcriber import WhisperTranscriber
        transcriber = WhisperTranscriber(model='gpt-4o-transcribe')
        return {"text": transcriber.transcribe(audio_file)}

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: voicepipe-ultra-fast [start|stop|toggle]")
        sys.exit(1)
    
    cmd = sys.argv[1]
    
    try:
        if cmd == "start":
            status = send_cmd("status")
            if status.get('status') == 'recording':
                sys.exit(0)  # Already recording
            
            result = send_cmd("start")
            if 'error' in result:
                print(f"Error: {result['error']}")
                
        elif cmd == "stop":
            status = send_cmd("status")
            if status.get('status') != 'recording':
                sys.exit(0)  # Not recording
                
            result = send_cmd("stop")
            if 'error' not in result and 'audio_file' in result:
                # Transcribe
                trans_result = transcribe_audio(result['audio_file'])
                if 'text' in trans_result:
                    print(trans_result['text'])
                # Clean up
                if os.path.exists(result['audio_file']):
                    os.unlink(result['audio_file'])
                    
        elif cmd == "toggle":
            status = send_cmd("status")
            if status.get('status') == 'recording':
                # Stop and transcribe
                result = send_cmd("stop")
                if 'error' not in result and 'audio_file' in result:
                    trans_result = transcribe_audio(result['audio_file'])
                    if 'text' in trans_result and trans_result['text']:
                        subprocess.run(['xdotool', 'type', '--', trans_result['text']], 
                                     capture_output=True)
                    # Clean up
                    if os.path.exists(result['audio_file']):
                        os.unlink(result['audio_file'])
            else:
                # Start recording
                send_cmd("start")
                
    except socket.error:
        print("Error: Cannot connect to daemon")
        sys.exit(1)